{"version":3,"sources":["constants/cellStatus.js","components/Cell.js","components/Grid.js","constants/gridStatus.js","components/GridToolbar.js","algorithms/helper.js","components/GridWrapper.js","data structures/PriorityQueue.js","data structures/CellNode.js","algorithms/algorithmA.js","components/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["CELL_STATUS","getCellStyle","baseStyle","status","Cell","rowIndex","colIndex","handleOnCellClick","className","onClick","Grid","gridCells","map","row","key","cellStatus","GRID_STATUS","GridWrapper","gridStatus","onGridStatusChange","onStart","isReadyToStart","ToggleButtonGroup","value","exclusive","onChange","aria-label","ToggleButton","Button","variant","color","disabled","getRandomInt","min","max","Math","ceil","floor","random","isAWall","col","wallCoords","i","length","wallRowIndex","wallColIndex","numOfRows","numOfCols","pathfindingAlgorithm","useState","setGridStatus","setGridCells","startCellCoords","setStartCellCoords","round","endCellCoords","setEndCellCoords","setWallCoords","setIsReadyToStart","useEffect","cells","currentRow","startRowIndex","startColIndex","endRowIndex","endColIndex","push","generateCells","updateCellStatus","cellRowIndex","cellColIndex","newCellStatus","prevGridCells","newGridCells","JSON","parse","stringify","setNewStartCoords","newStartRowIndex","newStartColIndex","prevStartRowIndex","prevStartColIndex","setNewEndCoords","newEndRowIndex","newEndColIndex","prevEndRowIndex","prevEndColIndex","addNewWall","newWallRowIndex","newWallColIndex","isARelevantPathCell","clearGrid","resetGrid","randomizeGrid","randomStartRowIndex","randomStartColIndex","randomEndRowIndex","randomEndColIndex","numOfWalls","randomWallRowIndex","randomWallColIndex","Paper","_","newWallCoords","filter","wallCoord","removeExisitingWall","PriorityQueueElement","element","priority","this","PriorityQueue","items","priorityQueueElement","isEmpty","last","splice","shift","equals","queuedPriorityElement","queuedElement","queuedPriorityElementIndex","indexOf","CellNode","actualCost","previousCellNode","costValue","object","algorithmA","totalNumOfRows","totalNumOfCols","openQueue","closedMap","startingCellNode","enqueue","isValidAdjacentCell","isNaN","isCoordOffGrid","isInClosedMap","addAdjacentCellNode","currentNode","adjacentCellRowIndex","adjacentCellColIndex","adjacentNode","setPreviousNode","setActualCost","fromRow","fromCol","toRow","toCol","heuristicCost","abs","adjacentNodePriority","contains","getPriorityOf","remove","dequeue","toString","shortestPath","unshift","PathfindingVisualizer","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.55fe7d3d.chunk.js","sourcesContent":["export const CELL_STATUS = {\r\n  UNVISITED: \"UNVISITED\",\r\n  START: \"START\",\r\n  END: \"END\",\r\n  CHECKING: \"CHECKING\",\r\n  VISITED: \"VISITED\",\r\n  WALL: \"WALL\",\r\n  PATH: \"PATH\",\r\n};\r\n","import React from \"react\";\r\nimport { CELL_STATUS } from \"../constants/cellStatus\";\r\n\r\nimport \"../assets/stylesheets/Cell.scss\";\r\n\r\nconst BASE_CELL_STYLE = \"cell\";\r\n\r\nconst getCellStyle = (baseStyle, status) => {\r\n  switch (status) {\r\n    case CELL_STATUS.START:\r\n      return `${baseStyle}--start`;\r\n    case CELL_STATUS.END:\r\n      return `${baseStyle}--end`;\r\n    case CELL_STATUS.CHECKING:\r\n      return `${baseStyle}--checking`;\r\n    case CELL_STATUS.VISITED:\r\n      return `${baseStyle}--visited`;\r\n    case CELL_STATUS.WALL:\r\n      return `${baseStyle}--wall`;\r\n    case CELL_STATUS.PATH:\r\n      return `${baseStyle}--path`;\r\n    default:\r\n      return \"\";\r\n  }\r\n};\r\n\r\nconst Cell = ({ status, rowIndex, colIndex, handleOnCellClick }) => {\r\n  return (\r\n    <div\r\n      className={`${BASE_CELL_STYLE} ${getCellStyle(BASE_CELL_STYLE, status)}`}\r\n      onClick={() => handleOnCellClick(status, rowIndex, colIndex)}\r\n    />\r\n  );\r\n};\r\n\r\nexport default Cell;\r\n","import React from \"react\";\r\nimport Cell from \"./Cell\";\r\n\r\nimport \"../assets/stylesheets/Grid.scss\";\r\n\r\nconst Grid = ({ gridCells, handleOnCellClick }) => {\r\n  return (\r\n    <div className=\"grid\">\r\n      {gridCells.map((row, rowIndex) => (\r\n        <div key={rowIndex} className=\"grid-row\">\r\n          {row.map((cellStatus, colIndex) => (\r\n            <Cell\r\n              key={`${(rowIndex, colIndex)}`}\r\n              status={cellStatus}\r\n              rowIndex={rowIndex}\r\n              colIndex={colIndex}\r\n              handleOnCellClick={handleOnCellClick}\r\n            />\r\n          ))}\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Grid;\r\n","export const GRID_STATUS = {\r\n  DEFAULT: \"DEFAULT\",\r\n  SET_START: \"SET_START\",\r\n  SET_END: \"SET_END\",\r\n  SET_WALL: \"SET_WALL\",\r\n  CLEAR_GRID: \"CLEAR_GRID\",\r\n  RESET_GRID: \"RESET_GRID\",\r\n  RANDOMIZE: \"RANDOMIZE\",\r\n};\r\n","import React from \"react\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport ToggleButton from \"@material-ui/lab/ToggleButton\";\r\nimport ToggleButtonGroup from \"@material-ui/lab/ToggleButtonGroup\";\r\nimport { GRID_STATUS } from \"../constants/gridStatus\";\r\n\r\nimport \"../assets/stylesheets/GridToolbar.scss\";\r\n\r\nconst GridWrapper = ({\r\n  gridStatus,\r\n  onGridStatusChange,\r\n  onStart,\r\n  isReadyToStart,\r\n}) => {\r\n  return (\r\n    <div className=\"grid-toolbar\">\r\n      <ToggleButtonGroup\r\n        value={gridStatus}\r\n        exclusive\r\n        onChange={onGridStatusChange}\r\n        aria-label=\"grid status selector\"\r\n      >\r\n        <ToggleButton value={GRID_STATUS.SET_START} aria-label=\"Set start\">\r\n          Set start\r\n        </ToggleButton>\r\n        <ToggleButton value={GRID_STATUS.SET_END} aria-label=\"Set end\">\r\n          Set end\r\n        </ToggleButton>\r\n        <ToggleButton value={GRID_STATUS.SET_WALL} aria-label=\"Set wall\">\r\n          Set wall\r\n        </ToggleButton>\r\n        <ToggleButton value={GRID_STATUS.RANDOMIZE} aria-label=\"Randomize grid\">\r\n          Randomize\r\n        </ToggleButton>\r\n        <ToggleButton value={GRID_STATUS.RESET_GRID} aria-label=\"Reset grid\">\r\n          Reset grid\r\n        </ToggleButton>\r\n        <ToggleButton value={GRID_STATUS.CLEAR_GRID} aria-label=\"Clear grid\">\r\n          Clear grid\r\n        </ToggleButton>\r\n      </ToggleButtonGroup>\r\n      <Button\r\n        variant=\"contained\"\r\n        color=\"primary\"\r\n        className=\"start-btn\"\r\n        onClick={() => onStart()}\r\n        disabled={!isReadyToStart}\r\n      >\r\n        Start\r\n      </Button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GridWrapper;\r\n","export const getManhattanDistance = (fromRow, fromCol, toRow, toCol) => {\r\n  return Math.abs(fromRow - toRow) + Math.abs(fromCol - toCol);\r\n};\r\n\r\nexport const getRandomInt = (min, max) => {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min)) + min;\r\n};\r\n","import React, { useState, useEffect } from \"react\";\r\nimport Paper from \"@material-ui/core/Paper\";\r\nimport Grid from \"./Grid\";\r\nimport GridToolbar from \"./GridToolbar\";\r\nimport { getRandomInt } from \"../algorithms/helper\";\r\nimport { GRID_STATUS } from \"../constants/gridStatus\";\r\nimport { CELL_STATUS } from \"../constants/cellStatus\";\r\nimport \"../assets/stylesheets/GridWrapper.scss\";\r\n\r\nconst isAWall = (row, col, wallCoords) => {\r\n  for (let i = 0; i < wallCoords.length; i++) {\r\n    const [wallRowIndex, wallColIndex] = wallCoords[i];\r\n    if (row === wallRowIndex && col === wallColIndex) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nconst generateCells = (\r\n  numOfRows,\r\n  numOfCols,\r\n  startCellCoords,\r\n  endCellCoords,\r\n  wallCoords\r\n) => {\r\n  const cells = [];\r\n  for (let row = 0; row < numOfRows; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < numOfCols; col++) {\r\n      const [startRowIndex, startColIndex] = startCellCoords;\r\n      const [endRowIndex, endColIndex] = endCellCoords;\r\n\r\n      if (row === startRowIndex && col === startColIndex) {\r\n        currentRow.push(CELL_STATUS.START);\r\n      } else if (row === endRowIndex && col === endColIndex) {\r\n        currentRow.push(CELL_STATUS.END);\r\n      } else if (isAWall(row, col, wallCoords)) {\r\n        currentRow.push(CELL_STATUS.WALL);\r\n      } else {\r\n        currentRow.push(CELL_STATUS.UNVISITED);\r\n      }\r\n    }\r\n    cells.push(currentRow);\r\n  }\r\n  return cells;\r\n};\r\n\r\nconst GridWrapper = ({ numOfRows, numOfCols, pathfindingAlgorithm }) => {\r\n  const [gridStatus, setGridStatus] = useState(GRID_STATUS.DEFAULT);\r\n  const [gridCells, setGridCells] = useState([]);\r\n  const [startCellCoords, setStartCellCoords] = useState([\r\n    Math.floor(numOfRows / 2),\r\n    Math.floor(numOfCols / 6),\r\n  ]);\r\n  const [endCellCoords, setEndCellCoords] = useState([\r\n    Math.floor(numOfRows / 2),\r\n    numOfCols - Math.round(numOfCols / 6),\r\n  ]);\r\n  const [wallCoords, setWallCoords] = useState([]);\r\n  const [isReadyToStart, setIsReadyToStart] = useState(true);\r\n\r\n  useEffect(() => {\r\n    const cells = generateCells(\r\n      numOfRows,\r\n      numOfCols,\r\n      startCellCoords,\r\n      endCellCoords,\r\n      wallCoords\r\n    );\r\n    setGridCells(cells);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (startCellCoords.length === 0 || endCellCoords.length === 0) {\r\n      setIsReadyToStart(false);\r\n    } else {\r\n      setIsReadyToStart(true);\r\n    }\r\n  }, [startCellCoords, endCellCoords]);\r\n\r\n  const updateCellStatus = (cellRowIndex, cellColIndex, newCellStatus) => {\r\n    setGridCells((prevGridCells) => {\r\n      const newGridCells = JSON.parse(JSON.stringify(prevGridCells));\r\n      newGridCells[cellRowIndex][cellColIndex] = newCellStatus;\r\n      return newGridCells;\r\n    });\r\n  };\r\n\r\n  const setNewStartCoords = (newStartRowIndex, newStartColIndex) => {\r\n    if (startCellCoords.length !== 0) {\r\n      const [prevStartRowIndex, prevStartColIndex] = startCellCoords;\r\n      updateCellStatus(\r\n        prevStartRowIndex,\r\n        prevStartColIndex,\r\n        CELL_STATUS.UNVISITED\r\n      );\r\n    }\r\n    setStartCellCoords([newStartRowIndex, newStartColIndex]);\r\n    updateCellStatus(newStartRowIndex, newStartColIndex, CELL_STATUS.START);\r\n  };\r\n\r\n  const setNewEndCoords = (newEndRowIndex, newEndColIndex) => {\r\n    if (endCellCoords.length !== 0) {\r\n      const [prevEndRowIndex, prevEndColIndex] = endCellCoords;\r\n      updateCellStatus(prevEndRowIndex, prevEndColIndex, CELL_STATUS.UNVISITED);\r\n    }\r\n\r\n    setEndCellCoords([newEndRowIndex, newEndColIndex]);\r\n    updateCellStatus(newEndRowIndex, newEndColIndex, CELL_STATUS.END);\r\n  };\r\n\r\n  const removeExisitingWall = (cellRowIndex, cellColIndex) => {\r\n    updateCellStatus(cellRowIndex, cellColIndex, CELL_STATUS.UNVISITED);\r\n    const newWallCoords = wallCoords.filter((wallCoord) => {\r\n      const [wallRowIndex, wallColIndex] = wallCoord;\r\n      return wallRowIndex !== cellRowIndex || wallColIndex !== cellColIndex;\r\n    });\r\n    setWallCoords(newWallCoords);\r\n  };\r\n\r\n  const addNewWall = (newWallRowIndex, newWallColIndex) => {\r\n    setWallCoords([...wallCoords, [newWallRowIndex, newWallColIndex]]);\r\n    updateCellStatus(newWallRowIndex, newWallColIndex, CELL_STATUS.WALL);\r\n  };\r\n\r\n  const isARelevantPathCell = (cellStatus) => {\r\n    return (\r\n      cellStatus === CELL_STATUS.START ||\r\n      cellStatus === CELL_STATUS.END ||\r\n      cellStatus === CELL_STATUS.WALL\r\n    );\r\n  };\r\n\r\n  const handleOnCellClick = (cellStatus, cellRowIndex, cellColIndex) => {\r\n    switch (gridStatus) {\r\n      case GRID_STATUS.SET_START:\r\n        if (!isARelevantPathCell(cellStatus)) {\r\n          resetGrid();\r\n          setNewStartCoords(cellRowIndex, cellColIndex);\r\n        }\r\n        break;\r\n      case GRID_STATUS.SET_END:\r\n        if (!isARelevantPathCell(cellStatus)) {\r\n          resetGrid();\r\n          setNewEndCoords(cellRowIndex, cellColIndex);\r\n        }\r\n        break;\r\n      case GRID_STATUS.SET_WALL:\r\n        resetGrid();\r\n        if (cellStatus === CELL_STATUS.WALL) {\r\n          removeExisitingWall(cellRowIndex, cellColIndex);\r\n        } else if (!isARelevantPathCell(cellStatus)) {\r\n          addNewWall(cellRowIndex, cellColIndex);\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  const handleGridStatusChange = (_, status) => {\r\n    switch (status) {\r\n      case GRID_STATUS.CLEAR_GRID:\r\n        clearGrid();\r\n        setGridStatus(GRID_STATUS.DEFAULT);\r\n        break;\r\n      case GRID_STATUS.RESET_GRID:\r\n        resetGrid();\r\n        setGridStatus(GRID_STATUS.DEFAULT);\r\n        break;\r\n      case GRID_STATUS.RANDOMIZE:\r\n        randomizeGrid();\r\n        setGridStatus(GRID_STATUS.DEFAULT);\r\n        break;\r\n      default:\r\n        setGridStatus(status);\r\n        break;\r\n    }\r\n  };\r\n\r\n  const clearGrid = () => {\r\n    setStartCellCoords([]);\r\n    setEndCellCoords([]);\r\n    setWallCoords([]);\r\n\r\n    for (let row = 0; row < numOfRows; row++) {\r\n      for (let col = 0; col < numOfCols; col++) {\r\n        updateCellStatus(row, col, CELL_STATUS.UNVISITED);\r\n      }\r\n    }\r\n  };\r\n\r\n  const resetGrid = () => {\r\n    for (let row = 0; row < numOfRows; row++) {\r\n      for (let col = 0; col < numOfCols; col++) {\r\n        const cellStatus = gridCells[row][col];\r\n        if (\r\n          cellStatus === CELL_STATUS.START ||\r\n          cellStatus === CELL_STATUS.END ||\r\n          cellStatus === CELL_STATUS.WALL\r\n        ) {\r\n          continue;\r\n        }\r\n        updateCellStatus(row, col, CELL_STATUS.UNVISITED);\r\n      }\r\n    }\r\n  };\r\n\r\n  const randomizeGrid = () => {\r\n    clearGrid();\r\n    const randomStartRowIndex = getRandomInt(0, numOfRows);\r\n    const randomStartColIndex = getRandomInt(0, numOfCols);\r\n    setNewStartCoords(randomStartRowIndex, randomStartColIndex);\r\n\r\n    let randomEndRowIndex = getRandomInt(0, numOfRows);\r\n    let randomEndColIndex = getRandomInt(0, numOfCols);\r\n    while (\r\n      randomStartRowIndex === randomEndRowIndex &&\r\n      randomStartColIndex === randomEndColIndex\r\n    ) {\r\n      randomEndRowIndex = getRandomInt(0, numOfRows);\r\n      randomEndColIndex = getRandomInt(0, numOfCols);\r\n    }\r\n\r\n    setNewEndCoords(randomEndRowIndex, randomEndColIndex);\r\n\r\n    const numOfWalls = getRandomInt(0, Math.floor((numOfRows * numOfCols) / 2));\r\n    for (let i = 0; i < numOfWalls; i++) {\r\n      let randomWallRowIndex = getRandomInt(0, numOfRows);\r\n      let randomWallColIndex = getRandomInt(0, numOfCols);\r\n\r\n      while (\r\n        (randomWallRowIndex === randomStartRowIndex &&\r\n          randomWallColIndex === randomStartColIndex) ||\r\n        (randomWallRowIndex === randomEndRowIndex &&\r\n          randomWallColIndex === randomEndColIndex)\r\n      ) {\r\n        randomWallRowIndex = getRandomInt(0, numOfRows);\r\n        randomWallColIndex = getRandomInt(0, numOfCols);\r\n      }\r\n      addNewWall(randomWallRowIndex, randomWallColIndex);\r\n    }\r\n  };\r\n\r\n  const handleOnStart = () => {\r\n    resetGrid();\r\n    pathfindingAlgorithm(\r\n      gridCells,\r\n      startCellCoords,\r\n      endCellCoords,\r\n      updateCellStatus\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <Paper className=\"grid-toolbar-wrapper\">\r\n        <GridToolbar\r\n          gridStatus={gridStatus}\r\n          onGridStatusChange={handleGridStatusChange}\r\n          onStart={handleOnStart}\r\n          isReadyToStart={isReadyToStart}\r\n        />\r\n      </Paper>\r\n      <Grid gridCells={gridCells} handleOnCellClick={handleOnCellClick} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GridWrapper;\r\n","class PriorityQueueElement {\r\n  constructor(element, priority) {\r\n    this.element = element;\r\n    this.priority = priority;\r\n  }\r\n}\r\n\r\nclass PriorityQueue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  enqueue(element, priority) {\r\n    const priorityQueueElement = new PriorityQueueElement(element, priority);\r\n\r\n    if (this.isEmpty()) {\r\n      this.items.push(priorityQueueElement);\r\n    } else if (this.last().priority <= priority) {\r\n      this.items.push(priorityQueueElement);\r\n    } else {\r\n      for (let i = 0; i < this.items.length; i++) {\r\n        this.items.splice(i, 0, priorityQueueElement);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  dequeue() {\r\n    if (this.isEmpty()) {\r\n      return null;\r\n    }\r\n    return this.items.shift();\r\n  }\r\n\r\n  first() {\r\n    if (this.isEmpty()) {\r\n      return null;\r\n    }\r\n    return this.items[0];\r\n  }\r\n\r\n  last() {\r\n    if (this.isEmpty()) {\r\n      return null;\r\n    }\r\n    return this.items[this.items.length - 1];\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  contains(element) {\r\n    for (let i = 0; i < this.items.length; i++) {\r\n      const queuedElement = this.items[i].element;\r\n      if (queuedElement.equals(element)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getPriorityOf(element) {\r\n    for (let i = 0; i < this.items.length; i++) {\r\n      const queuedElement = this.items[i].element;\r\n      if (queuedElement.equals(element)) {\r\n        return this.items[i].priority;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  remove(element) {\r\n    let queuedPriorityElement = null;\r\n    for (let i = 0; i < this.items.length; i++) {\r\n      const queuedElement = this.items[i].element;\r\n      if (queuedElement.equals(element)) {\r\n        queuedPriorityElement = queuedElement;\r\n      }\r\n    }\r\n\r\n    if (queuedPriorityElement === null) return;\r\n\r\n    const queuedPriorityElementIndex = this.items.indexOf(\r\n      queuedPriorityElement\r\n    );\r\n    this.items.splice(queuedPriorityElementIndex, 1);\r\n  }\r\n}\r\n\r\nexport default PriorityQueue;\r\n","class CellNode {\r\n  constructor(rowIndex, colIndex, status) {\r\n    this.rowIndex = rowIndex;\r\n    this.colIndex = colIndex;\r\n    this.status = status;\r\n    this.actualCost = 0;\r\n    this.previousCellNode = null;\r\n  }\r\n\r\n  setActualCost(costValue) {\r\n    this.actualCost = costValue;\r\n  }\r\n\r\n  setPreviousNode(previousCellNode) {\r\n    this.previousCellNode = previousCellNode;\r\n  }\r\n\r\n  toString() {\r\n    return `[${this.rowIndex}, ${this.colIndex}]`;\r\n  }\r\n\r\n  equals(object) {\r\n    if (object === null) {\r\n      return false;\r\n    }\r\n\r\n    if (!(object instanceof CellNode)) {\r\n      return false;\r\n    }\r\n\r\n    if (object.rowIndex !== this.rowIndex) {\r\n      return false;\r\n    }\r\n\r\n    if (object.colIndex !== this.colIndex) {\r\n      return false;\r\n    }\r\n\r\n    if (object.status !== this.status) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nexport default CellNode;\r\n","import PriorityQueue from \"../data structures/PriorityQueue\";\r\nimport { getManhattanDistance } from \"./helper\";\r\nimport CellNode from \"../data structures/CellNode\";\r\nimport { CELL_STATUS } from \"../constants/cellStatus\";\r\n\r\nconst algorithmA = (\r\n  gridCells,\r\n  startCellCoords,\r\n  endCellCoords,\r\n  updateCellStatus\r\n) => {\r\n  const totalNumOfRows = gridCells.length;\r\n  const totalNumOfCols = gridCells[0].length;\r\n\r\n  const openQueue = new PriorityQueue();\r\n  const closedMap = {};\r\n\r\n  const [startRowIndex, startColIndex] = startCellCoords;\r\n  const [endRowIndex, endColIndex] = endCellCoords;\r\n\r\n  const startingCellNode = new CellNode(\r\n    startRowIndex,\r\n    startColIndex,\r\n    gridCells[(startRowIndex, startColIndex)]\r\n  );\r\n\r\n  openQueue.enqueue(startingCellNode, 0);\r\n\r\n  const isCoordOffGrid = (rowIndex, colIndex) => {\r\n    if (rowIndex < 0 || rowIndex >= totalNumOfRows) return true;\r\n    if (colIndex < 0 || colIndex >= totalNumOfCols) return true;\r\n    return false;\r\n  };\r\n\r\n  const isAWall = (rowIndex, colIndex) => {\r\n    return gridCells[rowIndex][colIndex] === CELL_STATUS.WALL;\r\n  };\r\n\r\n  const isInClosedMap = (rowIndex, colIndex) => {\r\n    return `[${rowIndex}, ${colIndex}]` in closedMap;\r\n  };\r\n\r\n  const isValidAdjacentCell = (rowIndex, colIndex) => {\r\n    return (\r\n      !isNaN(rowIndex) &&\r\n      !isNaN(colIndex) &&\r\n      !isCoordOffGrid(rowIndex, colIndex) &&\r\n      !isAWall(rowIndex, colIndex) &&\r\n      !isInClosedMap(rowIndex, colIndex)\r\n    );\r\n  };\r\n\r\n  const addAdjacentCellNode = (\r\n    currentNode,\r\n    adjacentCellRowIndex,\r\n    adjacentCellColIndex\r\n  ) => {\r\n    if (!isValidAdjacentCell(adjacentCellRowIndex, adjacentCellColIndex)) {\r\n      return;\r\n    }\r\n\r\n    const adjacentNode = new CellNode(\r\n      adjacentCellRowIndex,\r\n      adjacentCellColIndex,\r\n      gridCells[adjacentCellRowIndex][adjacentCellColIndex]\r\n    );\r\n    adjacentNode.setPreviousNode(currentNode);\r\n    adjacentNode.setActualCost(currentNode.actualCost + 1);\r\n\r\n    const heuristicCost = getManhattanDistance(\r\n      adjacentNode.rowIndex,\r\n      adjacentNode.colIndex,\r\n      endRowIndex,\r\n      endColIndex\r\n    );\r\n\r\n    const adjacentNodePriority = adjacentNode.actualCost + heuristicCost;\r\n\r\n    if (openQueue.contains(adjacentNode)) {\r\n      const existingPriority = openQueue.getPriorityOf(adjacentNode);\r\n\r\n      if (adjacentNodePriority < existingPriority) {\r\n        openQueue.remove(adjacentNode);\r\n      }\r\n    }\r\n\r\n    updateCellStatus(\r\n      adjacentNode.rowIndex,\r\n      adjacentNode.colIndex,\r\n      CELL_STATUS.CHECKING\r\n    );\r\n\r\n    openQueue.enqueue(adjacentNode, adjacentNodePriority);\r\n  };\r\n\r\n  let currentNode = null;\r\n  while (!openQueue.isEmpty()) {\r\n    // dequeue node with lowest priority and assign to currentNode\r\n    currentNode = openQueue.dequeue().element;\r\n\r\n    // add currentNode into closed map\r\n    closedMap[currentNode.toString()] = currentNode;\r\n    updateCellStatus(\r\n      currentNode.rowIndex,\r\n      currentNode.colIndex,\r\n      CELL_STATUS.VISITED\r\n    );\r\n\r\n    if (\r\n      currentNode.rowIndex === endRowIndex &&\r\n      currentNode.colIndex === endColIndex\r\n    ) {\r\n      break;\r\n    }\r\n\r\n    // Top adjacent cell\r\n    const topCellRowIndex = currentNode.rowIndex - 1;\r\n    const topCellColIndex = currentNode.colIndex;\r\n    addAdjacentCellNode(currentNode, topCellRowIndex, topCellColIndex);\r\n\r\n    // Right adjacent cell\r\n    const rightCellRowIndex = currentNode.rowIndex;\r\n    const rightCellColIndex = currentNode.colIndex + 1;\r\n    addAdjacentCellNode(currentNode, rightCellRowIndex, rightCellColIndex);\r\n\r\n    // Bottom adjacent cell\r\n    const bottomCellRowIndex = currentNode.rowIndex + 1;\r\n    const bottomCellColIndex = currentNode.colIndex;\r\n    addAdjacentCellNode(currentNode, bottomCellRowIndex, bottomCellColIndex);\r\n\r\n    // Left adjacent cell\r\n    const leftCellRowIndex = currentNode.rowIndex;\r\n    const leftCellColIndex = currentNode.colIndex - 1;\r\n    addAdjacentCellNode(currentNode, leftCellRowIndex, leftCellColIndex);\r\n  }\r\n\r\n  if (\r\n    currentNode.rowIndex !== endRowIndex &&\r\n    currentNode.colIndex !== endColIndex\r\n  ) {\r\n    updateCellStatus(startRowIndex, startColIndex, CELL_STATUS.START);\r\n    return;\r\n  }\r\n\r\n  const shortestPath = [];\r\n  while (currentNode.previousCellNode !== null) {\r\n    shortestPath.unshift([currentNode.rowIndex, currentNode.colIndex]);\r\n    currentNode = currentNode.previousCellNode;\r\n  }\r\n  shortestPath.unshift([currentNode.rowIndex, currentNode.colIndex]);\r\n\r\n  for (let i = 0; i < shortestPath.length; i++) {\r\n    const [rowIndex, colIndex] = shortestPath[i];\r\n    let cellStatus;\r\n    if (i === 0) {\r\n      cellStatus = CELL_STATUS.START;\r\n    } else if (i === shortestPath.length - 1) {\r\n      cellStatus = CELL_STATUS.END;\r\n    } else {\r\n      cellStatus = CELL_STATUS.PATH;\r\n    }\r\n    updateCellStatus(rowIndex, colIndex, cellStatus);\r\n  }\r\n};\r\n\r\nexport default algorithmA;\r\n","import React, { useState } from \"react\";\r\nimport GridWrapper from \"./GridWrapper\";\r\nimport algorithmA from \"../algorithms/algorithmA\";\r\n\r\nconst PathfindingVisualizer = () => {\r\n  const [numOfRows, setNumOfRows] = useState(15);\r\n  const [numOfCols, setNumOfCols] = useState(35);\r\n\r\n  return (\r\n    <div>\r\n      <GridWrapper\r\n        numOfRows={numOfRows}\r\n        numOfCols={numOfCols}\r\n        pathfindingAlgorithm={algorithmA}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PathfindingVisualizer;\r\n","import React from \"react\";\nimport PathfindingVisualizer from \"./components/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div>\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}